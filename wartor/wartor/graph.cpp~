#include <SFML/Graphics.hpp>
#include <iostream>
#include <fstream>
#include <vector>
#include <utility> // For std::pair
#include <string>
#include <sstream>
#include <stdexcept>

int main() {
    // Read data from results.csv
    std::ifstream inputFile("results.csv");
    if (!inputFile.is_open()) {
        std::cerr << "Failed to open the CSV file." << std::endl;
        return 1;
    }

    std::vector<std::pair<int, float>> results; // Vector to store threads and execution times
    std::string line;

    // Read and skip the header row
    std::getline(inputFile, line);

    while (std::getline(inputFile, line)) {
        std::istringstream ss(line);
        std::string numThreadsStr, executionTimeStr;
        int numThreads;
        float executionTime;

        // Parse the CSV line and extract numeric data
        if (std::getline(ss, numThreadsStr, ',') && std::getline(ss, executionTimeStr, ',')) {
            try {
                numThreads = std::stoi(numThreadsStr);
                executionTime = std::stof(executionTimeStr);
                results.emplace_back(numThreads, executionTime);
            } catch (const std::invalid_argument& e) {
                std::cerr << "Invalid numeric value in CSV line: " << line << std::endl;
            }
        }
    }
    inputFile.close();

    // Check if we have any data to plot
    if (results.empty()) {
        std::cerr << "No data to plot." << std::endl;
        return 1;
    }

    // Create an SFML window
    sf::RenderWindow window(sf::VideoMode(800, 600), "Threads and Execution Times");

    // Create SFML text for displaying data
    sf::Font font;
    if (!font.loadFromFile("times.ttf")) {
        std::cerr << "Failed to load font." << std::endl;
        return 1;
    }

    sf::Text text;
    text.setFont(font);
    text.setCharacterSize(20);
    text.setFillColor(sf::Color::White);

    // Find the max number of threads and max execution time for scaling the graph
    int maxThreads = 0;
    float maxExecutionTime = 0.0f;
    for (const auto& result : results) {
        if (result.first > maxThreads) maxThreads = result.first;
        if (result.second > maxExecutionTime) maxExecutionTime = result.second;
    }

    // Define the scale factors to fit the chart in the window
    float xScale = 800.0f / maxThreads;
    float yScale = 800.0f / maxExecutionTime;

    // Create SFML line chart for execution times
    sf::VertexArray executionTimeChart(sf::LinesStrip, results.size());

    // Populate the chart with the execution times
    for (size_t i = 0; i < results.size(); ++i) {
        // Scale the points to fit in the window
        float x = results[i].first * xScale;
        float y = 600 - (results[i].second * yScale); // Invert y to have the origin at the bottom left
        executionTimeChart[i] = sf::Vertex(sf::Vector2f(x, y), sf::Color::Red);
    }

    // Main loop
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed) {
                window.close();
            }
        }

        window.clear();

        // Draw the line chart for execution times
        window.draw(executionTimeChart);

        window.display();
    }

    return 0;
}
