#include <SFML/Graphics.hpp>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <fstream>
#include <sstream> // Added for stringstream
#include <omp.h>

int gridSize = 2;
int windowWidth = 800;
int windowHeight = 600;
int numFish = 100;
int numSharks = 100;
int fishBreed = 10;
int sharkBreed = 10;
int starve = 20;
int maxThreads = 8;

// Define a structure to store simulation results
struct SimulationResult {
    int numThreads;
    double executionTime;
};

class Fish {
public:
    sf::RectangleShape shape;
    sf::Vector2i position;
    int breedTimer;
    int reproduceTimer;

    Fish(int x, int y) {
        shape.setSize(sf::Vector2f(gridSize, gridSize));
        shape.setFillColor(sf::Color::Blue);
        position.x = x;
        position.y = y;
        shape.setPosition(x * gridSize, y * gridSize);
        breedTimer = fishBreed;
        reproduceTimer = fishBreed; // Initialize reproduce timer
    }
void move(std::vector<Fish>& allFish) {
    // Random movement
    int dx = rand() % 3 - 1; // -1, 0, or 1
    int dy = rand() % 3 - 1; // -1, 0, or 1

    int newX = (position.x + dx + windowWidth / gridSize) % (windowWidth / gridSize);
    int newY = (position.y + dy + windowHeight / gridSize) % (windowHeight / gridSize);

    // Check if the new position is occupied
    for (const Fish& fish : allFish) {
        if (fish.position.x == newX && fish.position.y == newY) {
            return; // Skip the move if position is occupied
        }
    }

    // Update position
    position.x = newX;
    position.y = newY;
    shape.setPosition(position.x * gridSize, position.y * gridSize);

    // Decrement the breed timer
    breedTimer--;
}
};

class Shark {
public:
    sf::RectangleShape shape;
    sf::Vector2i position;
    int breedTimer;
    int starveTimer;
    int energy; // Add energy level for sharks

    Shark(int x, int y) {
        shape.setSize(sf::Vector2f(gridSize, gridSize));
        shape.setFillColor(sf::Color::Red);
        position.x = x;
        position.y = y;
        shape.setPosition(x * gridSize, y * gridSize);
        breedTimer = sharkBreed;
        starveTimer = starve;
        energy = starve; // Initialize energy to maximum
    }

    void move(std::vector<Fish>& fishes) {
        int dx = rand() % 3 - 1; // -1, 0, or 1
        int dy = rand() % 3 - 1; // -1, 0, or 1

        position.x += dx;
        position.y += dy;

        // Wrap around the grid
        position.x = (position.x + windowWidth / gridSize) % (windowWidth / gridSize);
        position.y = (position.y + windowHeight / gridSize) % (windowHeight / gridSize);

        shape.setPosition(position.x * gridSize, position.y * gridSize);
        breedTimer--;
        starveTimer--;
        energy--; // Decrement energy at each time step

        if (breedTimer <= 0) {
            breedTimer = sharkBreed;
        }

        // Check for nearby fish to eat
        for (std::vector<Fish>::size_type i = 0; i < fishes.size(); ++i) {
            if (position.x == fishes[i].position.x && position.y == fishes[i].position.y) {
                starveTimer = starve;
                energy += 5; // Gain energy from eating
                fishes.erase(fishes.begin() + i);
                break;
            }
        }

        // If starved, remove the shark
        if (starveTimer <= 0 || energy <= 0) {
            starveTimer = starve;
            position.x = -1; // Mark for removal
        }
    }
};

void saveResultsToCSV(const std::vector<SimulationResult>& results) {
    std::ofstream outputFile("results.csv");
    if (!outputFile.is_open()) {
        std::cerr << "Failed to open the CSV file for writing." << std::endl;
        return;
    }

    // Write CSV header
    outputFile << "NumThreads,ExecutionTime" << std::endl;

    // Write simulation results
    for (const SimulationResult& result : results) {
        outputFile << result.numThreads << "," << result.executionTime << std::endl;
    }

    outputFile.close();
}
void updateFish(std::vector<Fish>& fishes) {
    for (auto& fish : fishes) {
        fish.move(fishes);

        if (fish.breedTimer <= 0) {
            // Reset the breed timer
            fish.breedTimer = fishBreed;

            // Breed a new fish at the current position
            Fish newFish(fish.position.x, fish.position.y);
            fishes.push_back(newFish);
        }
    }
}

void updateSharks(std::vector<Shark>& sharks, std::vector<Fish>& fishes, int start, int end) {
    for (int i = start; i < end; i++) {
        sharks[i].move(fishes);

        if (sharks[i].breedTimer <= 0) {
            sharks[i].breedTimer = sharkBreed;

            int dx = rand() % 3 - 1; // -1, 0, or 1
            int dy = rand() % 3 - 1; // -1, 0, or 1

            int newX = (sharks[i].position.x + dx) % (windowWidth / gridSize);
            int newY = (sharks[i].position.y + dy) % (windowHeight / gridSize);

            bool empty = true;
            for (const Shark& shark : sharks) {
                if (shark.position.x == newX && shark.position.y == newY) {
                    empty = false;
                    break;
                }
            }

            if (empty) {
                Shark newShark(newX, newY);
                sharks.push_back(newShark);
            }
        }
    }
}

int main() {
    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), "Wator Simulation");
    std::vector<Fish> fishes;
    std::vector<Shark> sharks;
    std::srand(static_cast<unsigned>(std::time(nullptr)));

    std::vector<SimulationResult> results; // Store simulation results

    for (int numThreads = 1; numThreads <= maxThreads; numThreads++) {
        omp_set_num_threads(numThreads);

        for (int i = 0; i < numFish; ++i) {
            int x = rand() % (windowWidth / gridSize);
            int y = rand() % (windowHeight / gridSize);
            fishes.push_back(Fish(x, y));
        }

        for (int i = 0; i < numSharks; ++i) {
            int x = rand() % (windowWidth / gridSize);
            int y = rand() % (windowHeight / gridSize);
            sharks.push_back(Shark(x, y));
        }

        double startTime = omp_get_wtime();

        while (!fishes.empty() && !sharks.empty()) {
            sf::Event event;
            while (window.pollEvent(event)) {
                if (event.type == sf::Event::Closed)
                    window.close();
            }

            window.clear();

            #pragma omp parallel sections
            {
                #pragma omp section
                {
                    updateFish(fishes, 0, fishes.size());
                }
                #pragma omp section
                {
                    updateSharks(sharks, fishes, 0, sharks.size());
                }
            }

            sharks.erase(std::remove_if(sharks.begin(), sharks.end(), [](const Shark& shark) {
                return shark.position.x == -1;
            }), sharks.end());

            for (auto& fish : fishes) {
                window.draw(fish.shape);
            }

            for (auto& shark : sharks) {
                window.draw(shark.shape);
            }

            window.display();
        }

        double endTime = omp_get_wtime();
        double executionTime = endTime - startTime;
        std::cout << "Threads: " << numThreads << ", Execution Time: " << executionTime << " seconds" << std::endl;

        // Store the simulation result
        SimulationResult result;
        result.numThreads = numThreads;
        result.executionTime = executionTime;
        results.push_back(result);

        fishes.clear();
        sharks.clear();
    }

    // Save results to CSV
    saveResultsToCSV(results);

    return 0;
}
